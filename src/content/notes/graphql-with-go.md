---
title: Creating GraphQl in Go
date: 2025-09-12
description: Creating a schema first graphql api in go with sqlite3 db
draft: true
category: Go GraphQl
---

Note: Creating a GraphQL Server in Go with SQLite3

This note summarizes the key steps for building a GraphQL API, address-api, in Go with a SQLite database. The goal was to take scraped JSON data, migrate it to a database, and expose it through a GraphQL API using a schema-first approach with gqlgen.
1. Initial Project Structure ğŸ—ï¸

Organize the repo however, but I went with a typical enterprise structure because I wanted to understand this structure better. For this small project, all the code could have been in just a couple of files.

â”œâ”€â”€ cmd               # Main application entry points
â”‚   â”œâ”€â”€ server        # For the long-running API server
â”‚   â””â”€â”€ setup         # For one-time setup scripts (like DB migration)
â”œâ”€â”€ db                # Database-related files
â”‚   â””â”€â”€ migrations    # SQL files for schema changes
â”œâ”€â”€ internal          # Private application logic
â”‚   â””â”€â”€ repository    # Data access layer
â””â”€â”€ graph             # GraphQL generated code and resolvers

2. Database Migration ğŸšš

Move data from its source (e.g., JSON files) into your database.

    Create a Schema: Define your table structure in an .sql file (e.g., db/migrations/001_create_tables.sql).

    Write a Go Script: Create a one-time script (cmd/setup/main.go) that reads the source data, connects to the SQLite DB, creates the tables, and runs INSERT statements to populate it.

    Run the Migration: Execute the script before starting your server: go run ./cmd/setup.

    [!Note]
    The address-api repo also has a one-time script file, internal/data/cleanup.go, that cleans up each JSON file. I ran it once, hence it does not have tests associated with it.

3. GraphQL Schema-First Design ğŸ“

Define your API contract first, then generate the Go boilerplate.

    Initialize gqlgen:

    `go run [github.com/99designs/gqlgen](https://github.com/99designs/gqlgen) init`

    Define Your Schema: Edit graph/schema.graphqls to define your types, querys, and directives. Use camelCase for field names.

    Generate Go Code: Run the generate command to create Go models and resolver stubs.

    go run [github.com/99designs/gqlgen](https://github.com/99designs/gqlgen) generate

    [!Tip]
    Define the generate command in a Makefile. When you add a mutation or query in the future, you can simply run make generate.

4. Refactor to the Repository Pattern ğŸ›ï¸

To keep the code clean and testable, we separate the database logic (the "Chef") from the API logic (the "Waiter").

    Define an Interface: In the internal/repository package, create an interface that defines the data access methods (e.g., GetCountryCode). This is the "contract."

    Create a Concrete Repository: Create a struct (e.g., AddressRepository) with a *sql.DB field. Implement the interface methods on this struct. This is where all your SQL queries live.

    Inject the Repository: Update the main graph.Resolver struct to hold the repository interface, not the *sql.DB directly.

5. Implement Resolvers & Directives ğŸ”Œ

With the repository in place, the resolver's job becomes very simple.

    Update main.go:

        Create the DB connection.

        Create an instance of the repository (e.g., repo := repository.NewAddressRepository(db)).

        Create the main resolver, injecting the repository (resolver := &graph.Resolver{Repo: repo}).

    Write Resolver Logic: In graph/schema.resolvers.go, the resolver functions become simple one-liners that just call the corresponding method on the repository.

    func (r *queryResolver) CountryCodes(ctx context.Context, country *string) ([]*model.CountryInfo, error) {
        return r.Repo.GetCountryCode(ctx, country)
    }

    Implement Directives: For features like auth, implement the directive function that was generated by gqlgen.

6. Add Authentication ğŸ”

Protect specific queries so they require an API key.

    Update Schema: Add a directive definition (directive @auth on FIELD_DEFINITION) and apply it to a query (myQuery: String! @auth).

    Create HTTP Middleware: In main.go, create a middleware that reads the Authorization: Bearer <token> header and injects the token into the request context.

    Implement Directive: The Auth directive function reads the token from the context. If the token is valid, it calls next(ctx) to proceed; otherwise, it returns an error.

7. Write Tests ğŸ§ª

We used two types of tests for full coverage.

    Integration Tests (for the Repository):

        In internal/repository/, create a _test.go file.

        Use an in-memory SQLite database for each test to ensure a clean slate.

        Tests run the migration, seed data, call the repository method, and assert that the correct data is returned from the database. This proves your SQL is correct.

    Unit Tests (for the Resolvers):

        In graph/, create a _test.go file.

        Create a mock of the repository interface.

        Inject the mock into the resolver.

        Tests call the resolver and assert that the resolver correctly calls the mock and passes the data through. This proves your API layer is wired correctly.

8. Prepare for Deployment ğŸš€

Final steps to make the application portable and production-ready.

    Externalize Configuration: Move hardcoded values like API_KEY and DB_PATH out of the code and into a .env file (for local) or environment variables (for production).

    Add CORS: Use a middleware library like rs/cors in main.go to allow cross-origin requests from browser-based applications.

    Containerize with Docker: Create a multi-stage Dockerfile to build a small, static Go binary and copy it into a minimal final image (like alpine). This makes your application easy to deploy anywhere.
